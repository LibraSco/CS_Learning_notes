# 继电器与蜂鸣器 

蜂鸣器的分类：

- 有源蜂鸣器：内部带振荡源，只要一通电就会叫，声音频率固定。用的比较多

- 无源蜂鸣器：内部不带振荡源，必须要用方波来驱动它，用的少

---

https://pvuh.bmwca.cn/Yq9m3d

蜂鸣器和继电器程序控制顺序：

**P0输出——>打开锁存器（P27 P26 P25输出控制）——>关闭锁存器（让控制外设的数据稳定）**

程序解释(参考以上图片)：

1.P0口控制着继电器和蜂鸣器的打开和关闭。看左图的最右边，荧光笔标注部分，从上往下看（从0开始数），delay（继电器）在第四位，buzz(蜂鸣器)在第六位，所以通过对P0口第四位和第六位赋值0或1就可以控制继电器和蜂鸣器的开关。

2.打开锁存器，这个时候需要给P2口赋值，我们需要让Y5C打开，如图右半部分所示，那么P27=1，P26=0，P25=1，对P2字节赋值，P2=0xa0

3.关闭锁存器，直接对P2字节赋值为0即可

**【原则】：在打开锁存器前，需要保持P0数据的稳定；在关闭锁存器后，才可以操作P0改变数据，这样可以保护数据安全**

---

程序示例（标志位控制写法）：
```C
unsigned char buzzer_ctrl;//定义全局变量，buzzer_ctrl用来控制蜂鸣器
unsigned char relay_ctrl;//定义全局变量，relay_ctrl用来控制继电器
void vSystem_Init(void)
{
  buzzer_ctrl=0;
  relay_ctrl=1;
  P0=(buzzer_ctrl<<6)|(relay_ctrl<<4);//标志位控制
  P2=0xa0;//打开锁存器，控制ULN2003输出
  P2=0；//关闭锁存器
}
```
解释：

将relay_ctrl赋值为1，按十六进制写法，relay_ctrl=0x01，relay_ctrl<<4,即向左移动四位，就是0x0000 0001——>0x0001 0000,这样就可以对P0口的第四位进行赋值，也就可以控制继电器的开关了。蜂鸣器也是同理。

标志位控制的优点：

**让P0的数据同时输出**

**可以单独控制某一位**

---

最后，你可能有问题，为什么程序中需要那么多的芯片呢？

1.其实是因为板子上外设多，有LED，数码管，蜂鸣器，继电器等，**IO数量不够**，所以需要“译码器——锁存器”结构，让数据控制口P0分时控制外设。

2.单片机上的IO口的驱动能力有限，不足以驱动蜂鸣器，继电器的线圈。所以需要专门的驱动芯片来**增加驱动能力**（如ULN2003芯片）
